import tkinter as tk
from PIL import Image, ImageTk
from tkinter import filedialog

class PolygonDrawer:
    def __init__(self, root):
        self.root = root
        self.root.title("Polygon Drawer")
        
        # Load image
        self.image_path = filedialog.askopenfilename(title="Select an Image")
        self.image = Image.open(self.image_path)
        self.photo = ImageTk.PhotoImage(self.image)
        
        # Create Canvas
        self.canvas = tk.Canvas(root, width=self.image.width, height=self.image.height)
        self.canvas.pack()
        
        # Display image on canvas
        self.canvas.create_image(0, 0, image=self.photo, anchor=tk.NW)
        
        # Initialize variables
        self.points = []  # List to store points
        self.dots = []    # List to store dot objects
        self.lines = []   # List to store line objects
        self.context_menu = tk.Menu(root, tearoff=0)
        self.context_menu.add_command(label="Delete Polygon", command=self.delete_polygon)
        

        # Initialize dragging variables
        self.drag_data = {"item": None, "x": 0, "y": 0}

        # Bind mouse events
        self.canvas.bind("<Button-1>", self.add_or_select_point)  # Left click to add or select a point
        self.canvas.bind("<Button-3>", self.handle_right_click)    # Right click to delete or show context menu

        self.canvas.bind("<Button-1>", self.start_drag, add="+")    # Start dragging
        self.canvas.bind("<B1-Motion>", self.do_drag, add="+")       # Dragging motion
        self.canvas.bind("<ButtonRelease-1>", self.stop_drag, add="+") # Stop dragging


    def add_or_select_point(self, event):
        clicked_items = self.canvas.find_withtag("current")
        dot_size = 6

        if clicked_items and "dot" in self.canvas.gettags(clicked_items[0]):
            closest_dot = clicked_items[0]
            index = self.dots.index(closest_dot)
            selected_point = self.points[index]
            
            # Connect the selected dot to the last placed dot
            if len(self.points) > 0:
                line = self.canvas.create_line(self.points[-1], selected_point, fill="blue", tags="line")
                self.lines.append(line)
                # If it's a closed polygon, fill it
                self.check_and_fill_polygon()

            
        elif clicked_items and "line" in self.canvas.gettags(clicked_items[0]):
            #----NEEDS REDOING------
            # If clicked on a line, place a new dot on that line
            line = clicked_items[0]
            coords = self.canvas.coords(line)
            x1, y1, x2, y2 = coords
            new_point = (event.x, event.y)
            
            # Calculate the distance from the new point to each end of the line
            dist1 = ((new_point[0] - x1)**2 + (new_point[1] - y1)**2)**0.5
            dist2 = ((new_point[0] - x2)**2 + (new_point[1] - y2)**2)**0.5
            
            # Determine the order of insertion
            if dist1 < dist2:
                index = self.points.index((x1, y1)) + 1
            else:
                index = self.points.index((x2, y2))
            
            # Insert the new point into the points list and redraw the lines
            self.points.insert(index, new_point)
            self.redraw_polygon()

        else:
            # If no dot or line is selected, add a new dot
            x, y = event.x, event.y
            self.points.append((x, y))
            
            # Draw the point
            dot = self.canvas.create_oval(x-dot_size, y-dot_size, x+dot_size, y+dot_size, fill="red", tags="dot")
            self.dots.append(dot)
            
            # Connect points if there are more than one
            if len(self.points) > 1:
                line = self.canvas.create_line(self.points[-2], self.points[-1], fill="blue", tags="line")
                self.lines.append(line)

            # Bind hover events
            self.canvas.tag_bind(dot, "<Enter>", lambda e, d=dot: self.dot_on_hover_enter(e, d))
            self.canvas.tag_bind(dot, "<Leave>", lambda e, d=dot: self.dot_on_hover_leave(e, d))

            self.canvas.tag_bind(line, "<Enter>", lambda f, l=line: self.line_on_hover_enter(f, l))
            self.canvas.tag_bind(line, "<Leave>", lambda f, l=line: self.line_on_hover_leave(f, l))
            
    
    def dot_on_hover_enter(self, event, dot):
        self.canvas.itemconfig(dot, fill="yellow")
    
    def dot_on_hover_leave(self, event, dot):
        self.canvas.itemconfig(dot, fill="red")
    
    def line_on_hover_enter(self,event,line):
        self.canvas.itemconfig(line, fill="green")
    
    def line_on_hover_leave(self,event,line):
        self.canvas.itemconfig(line, fill="blue")

    
    def handle_right_click(self, event):
        clicked_items = self.canvas.find_withtag("current")
        
        if clicked_items and "dot" in self.canvas.gettags(clicked_items[0]):
            self.delete_point(event, clicked_items[0])
        else:
            self.show_context_menu(event)
    
    def delete_point(self, event, dot):
        index = self.dots.index(dot)
        point_to_delete = self.points[index]
        
        self.canvas.delete(dot)
        self.dots.pop(index)
        self.points.pop(index)
        
        lines_to_remove = []
        for line in self.lines:
            coords = self.canvas.coords(line)
            if (coords[:2] == [point_to_delete[0], point_to_delete[1]] or 
                coords[2:] == [point_to_delete[0], point_to_delete[1]]):
                lines_to_remove.append(line)
        
        for line in lines_to_remove:
            self.canvas.delete(line)
            self.lines.remove(line)
        
        self.redraw_polygon()
    
    def show_context_menu(self, event):
        clicked_items = self.canvas.find_withtag("current")
        if not clicked_items or ("dot" not in self.canvas.gettags(clicked_items[0]) and 
                                 "line" not in self.canvas.gettags(clicked_items[0])):
            self.context_menu.post(event.x_root, event.y_root)
    
    def delete_polygon(self):
        for dot in self.dots:
            self.canvas.delete(dot)
        for line in self.lines:
            self.canvas.delete(line)
        self.points.clear()
        self.dots.clear()
        self.lines.clear()
    
    def redraw_polygon(self):
        for line in self.lines:
            self.canvas.delete(line)
        self.lines.clear()
        if len(self.points) > 1:
            for i in range(len(self.points) - 1):
                line = self.canvas.create_line(self.points[i], self.points[i+1], fill="blue", tags="line")
                self.lines.append(line)
        self.check_and_fill_polygon()
    
    def check_and_fill_polygon(self):
        if len(self.points) > 2 and self.points[0] == self.points[-1]:
            print("Polygon Valid")
            self.canvas.create_polygon(self.points, fill="blue", outline="blue", tags="polygon")

    def start_drag(self, event):
        item = self.canvas.find_withtag("current")[0]
        if "dot" in self.canvas.gettags(item):
            self.drag_data["item"] = item
            self.drag_data["x"] = event.x
            self.drag_data["y"] = event.y
    
    def do_drag(self, event):
        if self.drag_data["item"]:
            item = self.drag_data["item"]
            dx = event.x - self.drag_data["x"]
            dy = event.y - self.drag_data["y"]
            
            # Move the dot and update the coordinates
            self.canvas.move(item, dx, dy)
            index = self.dots.index(item)
            old_x, old_y = self.points[index]
            new_x, new_y = old_x + dx, old_y + dy
            self.points[index] = (new_x, new_y)
            
            self.drag_data["x"] = event.x
            self.drag_data["y"] = event.y
            
            self.redraw_polygon()  # Redraw polygon to reflect new positions
    
    def stop_drag(self, event):
        self.drag_data["item"] = None
    
if __name__ == "__main__":
    root = tk.Tk()
    app = PolygonDrawer(root)
    root.mainloop()
