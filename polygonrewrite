import tkinter as tk 
from PIL import Image, ImageTk, ImageDraw
from tkinter import filedialog
import numpy as np
import os

class PolygonDrawer:
    """
    #Window that enables the user to draw on the image required
    #Features:
    -Dots can be individually placed, deletable
    -Lines automatically generate between each dot
    -The space fills with a choosable color
    -The whole polygon can be removed
    #Features to be added
    -Points/Line color/size needs to be adjustable
    """
    def __init__(self,root):
        #Defining windows
        self.root = root
        self.root.title("Polygon Drawer")
        


        pad_frame = tk.Frame(borderwidth = 0, background="bisque", width = 200,height=200)
        # pad_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=20)
        pad_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=20)
        #Loading image
        #--To be changed to a button next time--
        #--Must be dynamic, able to change the image whenever
        self.image_path = filedialog.askopenfilename(title="Select an image")
        self.time = os.path.basename(self.image_path)[5:8]
        self.pilimage = Image.open(self.image_path)
        self.photo = ImageTk.PhotoImage(self.pilimage)
        
        #ORIGINAL SCALE INFORMATION
        self.original_width = self.pilimage.width
        self.original_height = self.pilimage.height
        self.points = []

        self.aspect_ratio = self.original_width/self.original_height
        #Create Canvas
        self.canvas = tk.Canvas(root, width=self.pilimage.width, height=self.pilimage.height,highlightbackground="blue", highlightthickness=1,scrollregion=(0, 0, 0, 0))
        
        def set_aspect(content_frame, pad_frame, aspect_ratio):
        # Taken from user Bryan Oakley : https://stackoverflow.com/a/16548607
        # a function which places a frame within a containing frame, and
        # then forces the inner frame to keep a specific aspect ratio

            def enforce_aspect_ratio(event):
                # when the pad window resizes, fit the content into it,
                # either by fixing the width or the height and then
                # adjusting the height or width based on the aspect ratio.

                # start by using the width as the controlling dimension
                desired_width = event.width
                desired_height = int(event.width / aspect_ratio)

                # if the window is too tall to fit, use the height as
                # the controlling dimension
                if desired_height > event.height:
                    desired_height = event.height
                    desired_width = int(event.height * aspect_ratio)

                # place the window, giving it an explicit size
                content_frame.place(in_=pad_frame, x=0, y=0, 
                    width=desired_width, height=desired_height)

            pad_frame.bind("<Configure>", enforce_aspect_ratio)
        set_aspect(self.canvas,pad_frame, aspect_ratio=self.aspect_ratio)
        self.root.rowconfigure(0, weight=1)
        self.root.columnconfigure(0,weight=1)
        pad_frame.config(width=self.original_width, height=self.original_height)

        #Save image button
        self.savedialog = tk.Frame(master=self.root)
        self.savedialog.grid(row=1, column=0, padx=5, pady=5)

        self.label = tk.Label(master=self.savedialog, text="test")
        btn = tk.Button(master=self.savedialog, text="Save Image", command=self.save_mask)
        self.label.grid(row=0, column=0,padx=5, pady=5)
        btn.grid(row=1, column=0, padx=5, pady=5)

        #Display image on canvas
        self.canvimg=self.canvas.create_image(0,0,image=self.photo, anchor=tk.NW, tags="image") #tagged to easily access from the canvas items

        #------BINDINGS-------
        # Bind canvas resize event
        self.root.bind("<Configure>", self.on_resize)

        #Binding mouse actions
        self.canvas.bind("<Button-1>", self.on_mouse_down)
        self.canvas.bind("<B1-Motion>", self.do_drag)
        self.canvas.bind("<ButtonRelease-1>", self.on_mouse_up)
        self.canvas.bind("<Button-3>", self.handle_right_click)
        
        #CURRENT SCALE INFORMATION
        self.current_width = self.canvas.winfo_width()
        self.current_height = self.canvas.winfo_height()
        self.scaledpoints = []

        #-------VARIABLES-------
        self.scale_factor = 1.0

        self.last_width = self.original_width
        self.last_height = self.original_height
        self.item_scale_factor = self.scale_factor

        self.event_data = {"item": None, "x": 0, "y": 0, "type": None}
        self.drag_threshold = 5 #Threshold in pixels to determine if the movement is large enough
        self.is_dragging = False

        self.dot_size = 6
        self.line_width = 3

        
        self.dots = []
        self.lines = []
        self.polygon = None
        self.drawptbtwline = True
        self.context_menu = tk.Menu(root, tearoff=0)
        self.context_menu.add_command(label="Delete Polygon", command=self.delete_polygon)

        #-------COLORS-------
        #Eventually these will be adjustable
        self.dotcolor = "#E2856E"
        self.dothovercolor = "#55DDE0"
        self.linecolor = "#001C55"
        self.linehovercolor = "#55DDE0"

        self.polygoncolor = (0,0,255,int(0.2*255))

    def on_resize(self,event):
         #Implemented from https://www.tutorialspoint.com/how-to-set-the-canvas-size-properly-in-tkinter
        #Initializing new width and height        
        scale_x = self.canvas.winfo_width() / self.original_width
        scale_y = self.canvas.winfo_height() / self.original_height

        self.current_width = self.canvas.winfo_width()
        self.current_height = self.canvas.winfo_height()

        # print("originalwidth: ", self.original_width)
        # print("original_height: ", self.original_height)
        
        # Choose the smaller scale factor to maintain aspect ratio
        self.scale_factor = min(scale_x, scale_y)
        # print("scale_factor: ", self.scale_factor)

        # Calculate new width and height while maintaining aspect ratio
        new_width = int(self.original_width * self.scale_factor)
        new_height = int(self.original_height * self.scale_factor)

        #Debugging step - for whatever reason it initializes at 0
        if new_height == 0:
            new_height = 1

        # print("new_width: ", new_width)
        # print("new_height: ", new_height)

        #Scaling image and photo
        scaled_image = self.pilimage.resize((new_width, new_height), Image.Resampling.LANCZOS)
        self.scaled_photo = ImageTk.PhotoImage(scaled_image)

        #Update canvas and the image size
        self.canvas.config(width=new_width,height = new_height)
        self.canvas.itemconfig(self.canvimg, image=self.scaled_photo)

        #Item scaling information
        self.item_scale_factor = new_width / self.last_width
        self.last_width = new_width

        # Scale the dots, lines, and polygons based on the original positions and new scale factor
        items = self.canvas.find_all()
        for item in items:
            self.canvas.scale(item, 0,0, self.item_scale_factor, self.item_scale_factor)
        
        self.scalepoints()
        self.redraw_polygon()

    def on_mouse_down(self,event):
        self.event_data["x"]=event.x
        self.event_data["y"] = event.y
        #This information is collected from the current scale

        clicked_items = self.canvas.find_withtag("current") #Represents the top-most item directly under the mouse

        if clicked_items and "dot" in self.canvas.gettags(clicked_items[0]):
            self.event_data["item"] = clicked_items[0]
            self.event_data["type"] = "dot"
            self.is_dragging = False #Initialize with false, before checking
        elif clicked_items and "line" in self.canvas.gettags(clicked_items[0]):
            self.event_data["item"] = clicked_items[0]
            self.event_data["type"] = "line"
            self.is_dragging = False
            self.drawptbtwline = True
        elif clicked_items and "polygon" in self.canvas.gettags(clicked_items[0]):
            #Need to be able drag the whole polygon
            #self.event_data["item"] = clicked_items[0]
            # self.event_data["type"] = "polygon"       
            return
        else:
            self.event_data["item"]=None
            #In this event, it just places a point at the point, after the mouse is released
    
    def on_mouse_up(self, event):
        if not self.is_dragging and self.event_data["item"] is None:
            self.add_point(event)
        elif not self.is_dragging and self.event_data["type"] == "line" and self.drawptbtwline:
            #Gets triggered because its no longer dragging and has just clicked a line
            self.pointbtwline(event, self.canvas.find_withtag("current")[0]) #Add point to line 
    
    def do_drag(self,event):
        """This function checks what item is being dragged and performs the action     
        """
        if self.event_data["item"]:
            dx = event.x - self.event_data["x"]
            dy = event.y - self.event_data["y"]

            #Check the drag threshold, then start dragging
            if abs(dx)>self.drag_threshold or abs(dy)>self.drag_threshold:
                self.is_dragging = True
                if self.event_data["type"] == "dot":
                    try:
                        index = self.dots.index(self.event_data["item"])
                    except ValueError:
                        return #Item was not found
                    self.canvas.move(self.event_data["item"], dx, dy)
                    # print(f"point moved {dx},{dy}")

                    #Update the new point coordinates
                    old_x, old_y = self.scaledpoints[index]
                    new_x, new_y = old_x + dx, old_y + dy

                    ogold_x, ogold_y = self.points[index]
                    self.points[index] = (ogold_x + dx/self.scale_factor, ogold_y + dy/self.scale_factor)
                    
                    self.scaledpoints[index] = (self.points[index][0]*self.scale_factor,self.points[index][1]*self.scale_factor)

                    self.event_data["x"] = event.x
                    self.event_data["y"] = event.y

                    self.redraw_polygon() 
                    #Cannot redraw all the points, as stops the dragging motion
                elif self.event_data["type"] == "line":
                    #Move all dots together then just redraw everything
                    for i in range(0,len(self.dots)):
                        self.canvas.move(self.dots[i], dx, dy)

                        old_x, old_y = self.scaledpoints[i]
                        new_x, new_y = old_x + dx, old_y + dy

                        ogold_x, ogold_y = self.points[i]
                        self.points[i] = (ogold_x + dx/self.scale_factor, ogold_y + dy/self.scale_factor)
                        self.scaledpoints[i] = (self.points[i][0]*self.scale_factor,self.points[i][1]*self.scale_factor)

                        # self.scaledpoints[i] = (new_x, new_y)
                        # self.points[i] = (new_x/self.scale_factor, new_y/self.scale_factor)
                        self.event_data["x"] = event.x
                        self.event_data["y"] = event.y

                        self.redraw_polygon()
                        self.drawptbtwline = False                             
            else:
                self.is_dragging = False
        return 

    def handle_right_click(self,event):
        clicked_items = self.canvas.find_withtag("current")

        if clicked_items and "dot" in self.canvas.gettags(clicked_items[0]):
                self.delete_point(event, clicked_items[0])
        else:
            self.show_context_menu(event)

    #----------POINT ACTIONS----------
    def draw_point(self,x,y):
        dot_size = self.dot_size * self.scale_factor
        dot = self.canvas.create_oval(x-dot_size, y-dot_size, x+dot_size, y+dot_size, fill=self.dotcolor, tags="dot")

        # Bind hover events to the dot
        self.canvas.tag_bind(dot, "<Enter>", lambda e, d=dot: self.on_hover_enter(e, d))
        self.canvas.tag_bind(dot, "<Leave>", lambda e, d=dot: self.on_hover_leave(e, d))

        # Bind drag events to the dot
        self.canvas.tag_bind(dot, "<ButtonPress-1>", self.on_mouse_down)
        self.canvas.tag_bind(dot, "<B1-Motion>", self.do_drag)
        self.canvas.tag_bind(dot, "<ButtonRelease-1>", self.on_mouse_up)

        return dot
    
    def scalepoints(self):
        self.scaledpoints = [(a * self.scale_factor, b * self.scale_factor) for a, b in self.points] #Scale all the original points to match the current scale
   
    def add_point(self,event):
        #ISSUE IS HERE SOMEWHERE DOUBLE CHECK
        x,y = event.x, event.y #Collect coords of event based on the current scale
        self.points.append((x/self.scale_factor, y/self.scale_factor)) #Coords of events based on the original scale
        self.scalepoints()        
        self.redraw_polygon()

        dot=self.draw_point(x,y)
        self.dots.append(dot) #Collecting the dot tagsx
        self.redraw_points()#Elevate all the points to the top

    def pointbtwline(self, event, line):
        # Get the exact coordinates where the user clicked
        new_x, new_y = event.x, event.y
        
        # Get the coordinates of the line
        coords = self.canvas.coords(line)
        x1, y1, x2, y2 = coords
        
        # Find the index of the line in the list of lines
        line_index = self.lines.index(line)
        
        # Insert the new point into the points list at the correct position
        # The new point should be inserted right after the starting point of the line
        start_point_index = line_index
        end_point_index = (line_index + 1) % len(self.points)
        
        self.scaledpoints.insert(end_point_index, (new_x, new_y))
        self.points.insert(end_point_index, (new_x/self.scale_factor,new_y/self.scale_factor))
        
        # Remove the old line since it will be replaced by two new lines
        self.canvas.delete(line)
        self.lines.pop(line_index)
        
        # Create two new lines: one from the first point to the new dot, and another from the new dot to the second point
        line1 = self.canvas.create_line(x1, y1, new_x, new_y, fill=self.linecolor, tags="line", width=self.line_width*self.scale_factor)
        line2 = self.canvas.create_line(new_x, new_y, x2, y2, fill=self.linecolor, tags="line", width=self.line_width*self.scale_factor)
        
        # Insert the new lines into the lines list at the correct positions
        self.lines.insert(line_index, line1)
        self.lines.insert(line_index + 1, line2)
        
        # Bind hover events to the new lines
        self.canvas.tag_bind(line1, "<Enter>", lambda e, l=line1: self.on_line_hover_enter(e, l))
        self.canvas.tag_bind(line1, "<Leave>", lambda e, l=line1: self.on_line_hover_leave(e, l))
        self.canvas.tag_bind(line2, "<Enter>", lambda e, l=line2: self.on_line_hover_enter(e, l))
        self.canvas.tag_bind(line2, "<Leave>", lambda e, l=line2: self.on_line_hover_leave(e, l))
        
        # Draw the new dot at the clicked position
        dot = self.draw_point(new_x, new_y)
        self.dots.insert(end_point_index, dot)

    def redraw_points(self):
        # Clear existing dots
        for dot in self.dots:
            self.canvas.delete(dot)
        self.dots.clear()

        # Draw the dots based on the scaled points list
        for (x, y) in self.scaledpoints:
            dot = self.draw_point(x, y)
            self.dots.append(dot)
        
        # Ensure that dots are always on top
        for dot in self.dots:
            self.canvas.tag_raise(dot)

    def delete_point(self, event, dot):
        if dot in self.dots:
            index = self.dots.index(dot)
            point_to_delete = self.scaledpoints[index]

            self.canvas.delete(dot)
            self.dots.pop(index)
            self.points.pop(index)
            self.scaledpoints.pop(index)

            # Delete lines connected to the point
            lines_to_remove = []
            for line in self.lines:
                coords = self.canvas.coords(line)
                if (coords[:2] == [point_to_delete[0], point_to_delete[1]] or 
                    coords[2:] == [point_to_delete[0], point_to_delete[1]]):
                    lines_to_remove.append(line)

            for line in lines_to_remove:
                self.canvas.delete(line)
                self.lines.remove(line)

            self.redraw_polygon()
   
    #----------POLYGON ACTIONS----------
    def show_context_menu(self, event):
        clicked_items = self.canvas.find_withtag("current")
        if not clicked_items or ("dot" not in self.canvas.gettags(clicked_items[0]) and 
                                 "line" not in self.canvas.gettags(clicked_items[0])):
            self.context_menu.post(event.x_root, event.y_root)
    
    def redraw_polygon(self):
        """This connects all dots present and draws the polygon contained within"""
        #Clear existing lines and polygons
        for line in self.lines:
            self.canvas.delete(line)
        self.lines.clear()

        if self.polygon:
            self.canvas.delete(self.polygon)
        self.polygon = None

        # Draw lines between points
        if len(self.scaledpoints) > 1:
            if len(self.scaledpoints) > 2:
                self.PILdrawpoly()
                poly = self.canvas.create_image(0, 0, image=self.polygon, anchor=tk.NW)
                lowest_item_id = self.canvas.find_all()[1]
                self.canvas.tag_lower(poly, lowest_item_id)
            for i in range(len(self.scaledpoints) - 1):
                line = self.canvas.create_line(self.scaledpoints[i], self.scaledpoints[i+1], fill=self.linecolor, tags="line", width = self.line_width*self.scale_factor)
                self.lines.append(line)
                # Bind hover events to the line
                self.canvas.tag_bind(line, "<Enter>", lambda e, l=line: self.on_line_hover_enter(e, l))
                self.canvas.tag_bind(line, "<Leave>", lambda e, l=line: self.on_line_hover_leave(e, l))

            if len(self.points) > 2 and self.points[0] != self.points[-1]:
                line = self.canvas.create_line(self.scaledpoints[-1], self.scaledpoints[0], fill=self.linecolor, tags="line", width = self.line_width*self.scale_factor)
                self.lines.append(line)
                self.canvas.tag_bind(line, "<Enter>", lambda e, l=line: self.on_line_hover_enter(e, l))
                self.canvas.tag_bind(line, "<Leave>", lambda e, l=line: self.on_line_hover_leave(e, l))
        for dot in self.dots:
            self.canvas.tag_raise(dot)

    def PILdrawpoly(self):
        overlay = Image.new('RGBA', (self.current_width, self.current_height), (255,255,255,0))
        draw = ImageDraw.Draw(overlay)
        #Draw the polygon on the image
        draw.polygon(self.scaledpoints, fill = self.polygoncolor)

        # Display the result on the canvas
        self.polygon = ImageTk.PhotoImage(overlay)
    
    def delete_polygon(self):
        for line in self.canvas.find_withtag("line"):
            self.canvas.delete(line)
        if self.polygon:
            self.canvas.delete(self.polygon)    
        for dot in self.canvas.find_withtag("dot"):
            self.canvas.delete(dot)
        self.points.clear()
        self.dots.clear()
        self.lines.clear()
        self.polygon = None

    def save_mask(self):
        mask = Image.new('L', self.pilimage.size, 0)
        draw = ImageDraw.Draw(mask)

        draw.polygon(self.points, outline=1, fill=255)
        
        folder_path = os.path.dirname(self.image_path) + "/segmented"
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)  # Creates folder and intermediate directories if they don't exist

        impath = folder_path + "/Segmented Slice" + self.time + ".png"
        mask.save(impath)

        #Maybe make this able to open the image/parent folder when clicked?
        self.label = tk.Label(master=self.savedialog, text=f"Image saved to {impath}")
        self.label.grid(row=0, column=0,padx=5, pady=5)

    #----------HOVER EVENTS----------
    def on_hover_enter(self, event, dot):
        self.canvas.itemconfig(dot, fill=self.dothovercolor)
    
    def on_hover_leave(self, event, dot):
        self.canvas.itemconfig(dot, fill=self.dotcolor)

    def on_line_hover_enter(self, event, line):
        self.canvas.itemconfig(line, fill=self.linehovercolor)

    def on_line_hover_leave(self, event, line):
        self.canvas.itemconfig(line, fill=self.linecolor)


if __name__ == "__main__":
       
       root=tk.Tk()
       app = PolygonDrawer(root)
       root.mainloop()